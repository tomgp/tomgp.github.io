<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<script src="/scripts/d3.v3.min.js"></script>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Book shelf</title>
	<style>
		body{
			background-color: #000;
			font-family: sans-serif;
		}
	</style>
</head>
<body>
</body>
<script>
	'use strict';
	var shelfHeight = 400;
	var nomalSpacing = 20;
	var pageWidth = 0.2;

	d3.csv('/data/books.csv', function(data){
		//SORT OUT THE DATA
		var sortOn = {
			date: function(a,b){ return b.date.getTime() - a.date.getTime(); }
		}

		var sheetDateFormat = d3.time.format("%Y-%m-%d");

		data = data.map(function(d){
			if(d.date){
				d.read = true;
				d.date = sheetDateFormat.parse(d.date);
			}else{
				d.read = false;
			}
			d.pages = Number(d.pages);
			return d;
		});

		var years = splitOn(data, function(d){
			if(d.date){
				return d.date.getFullYear();
			}
			return 'on the stack';
		});

		console.log(shelfLayout( years['2009'], pageWidth, nomalSpacing ));

		years = Object.keys(years).map(function(y){
			var books = data.filter(function(d){
				if(d.date){
					return (d.date.getFullYear() == y);
				}
				return false;
			});

			return {
				year: y,
				books: shelfLayout( books, pageWidth, nomalSpacing), 
				pageCount: d3.sum(books, function(b){ return b.pages; })
			};
		});

		var max = years.reduce(function(prev, cur, i, a){
			return {
				books: Math.max(prev.books, cur.books.length),
				pages: Math.max(prev.pages, cur.pageCount),
			};
		}, {books:0, pages:0});

		var width = (max.pages * pageWidth) + (max.books * nomalSpacing);

		//DRAW THE STUFF

		d3.select('body')
			.append('svg')
				.attr({
					height: years.length * shelfHeight,
					width: (max.pages * pageWidth) + (max.books * nomalSpacing)
				})
			.selectAll('g.shelf')
				.data(years).enter()
			.append('g')
				.attr({
					class:'shelf',
					transform:function(d,i){
						return 'translate(0,' + (i * shelfHeight) + ')';
					}
				})
			.call(function(shelf){
				shelf.selectAll('g')
					.data(function(d){ return d.books; })
						.enter()
					.append('g')
						.call(function(g){
							g.attr('transform',function(d){
								return 'translate(' + d.x + ',0)'}
							);

							g.append('rect')
								.attr({
									x: 0,
									y: function(d){
										if(d.data.comic) return shelfHeight -(shelfHeight*0.9);
										return shelfHeight - (shelfHeight*0.75);
									},
									width: function(d){ return d.width; },
									height: function(d){
										if(d.data.comic) return shelfHeight*0.9
										return shelfHeight*0.75
									},
									fill: '#FFF'
								});

							g.append('text')
								.attr({
									transform:function(d){
										return 'translate('+(d.width/2)+','+shelfHeight+') rotate(-90)'
									},
									dx:5,
									dy:4
								})
								.text(function(d){
									return d.data.title;
								})
						});
			})

	});

function shelfLayout(s, thickness, spacing){
	var acc = 0;

	return s.map(function(d){
		var o = {
			data: d,
			x: Math.floor(acc),
			width: Math.max( Math.floor( d.pages*thickness ), spacing)
		};

		acc += (o.width + spacing);

		return o;
	});
}

function splitOn(array, keyFunction){
	if(!keyFunction) keyFunction = function(d,i){ return i; };
	var splitUp = {};
	
	array.forEach(function(d,i){
		var key = keyFunction(d,i);
		if(!splitUp[key]) splitUp[key] = [];
		splitUp[key].push(d);
	})
	return splitUp;
}
</script>
</html>